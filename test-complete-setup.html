<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ Promptr Complete System Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        h2 {
            color: #6366f1;
            border-bottom: 3px solid #e5e7eb;
            padding-bottom: 10px;
            margin-top: 30px;
        }
        .step {
            background: #f8fafc;
            border-left: 4px solid #6366f1;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        .step-number {
            background: #6366f1;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }
        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        button {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }
        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .response {
            margin-top: 20px;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid;
        }
        .success {
            background: #d1fae5;
            border-color: #10b981;
            color: #065f46;
        }
        .error {
            background: #fee2e2;
            border-color: #ef4444;
            color: #991b1b;
        }
        .info {
            background: #dbeafe;
            border-color: #3b82f6;
            color: #1e40af;
        }
        .loading {
            background: #f3f4f6;
            border-color: #6366f1;
            color: #6366f1;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-success { background: #10b981; }
        .status-error { background: #ef4444; }
        .status-pending { background: #f59e0b; }
        .test-results {
            background: #f8fafc;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        .copy-btn {
            background: #6b7280;
            font-size: 12px;
            padding: 6px 12px;
        }
        .copy-btn:hover {
            background: #4b5563;
        }
    </style>
</head>
<body>
    <h1>üß™ Promptr System Test</h1>
    
    <!-- Configuration -->
    <div class="container">
        <h2>‚öôÔ∏è Step 1: Configuration</h2>
        <div class="step">
            <span class="step-number">1</span>
            <strong>Enter your Supabase project URL</strong>
        </div>
        <div class="form-group">
            <label for="supabaseUrl">Supabase URL:</label>
            <input type="text" id="supabaseUrl" placeholder="https://your-project.supabase.co" />
        </div>
        <div class="form-group">
            <label for="supabaseKey">Supabase anon key:</label>
            <input type="text" id="supabaseKey" placeholder="paste your public anon key starting with ey..." />
        </div>
        <div class="form-group">
            <label for="stripeSecret">Stripe webhook secret:</label>
            <input type="text" id="stripeSecret" placeholder="whsec_... (optional for local tests)" />
        </div>
        <button onclick="validateConfig()">‚úÖ Validate Configuration</button>
        <div id="configResponse"></div>
    </div>

    <!-- Database Test -->
    <div class="container">
        <h2>üóÑÔ∏è Step 2: Database Schema Test</h2>
        <div class="step">
            <span class="step-number">2</span>
            <strong>Test database schema and create a test user</strong>
        </div>
        <div class="form-group">
            <label for="testEmail">Test Email:</label>
            <input type="email" id="testEmail" value="test@example.com" />
        </div>
        <div class="form-group">
            <label for="testStatus">Initial Status:</label>
            <select id="testStatus">
                <option value="trialing">Trialing</option>
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
            </select>
        </div>
        <button onclick="createTestUser()">üë§ Create Test User</button>
        <button onclick="checkUserExists()">üîç Check User Exists</button>
        <div id="databaseResponse"></div>
    </div>

    <!-- Token Validation Test -->
    <div class="container">
        <h2>üîê Step 3: Token Validation Test</h2>
        <div class="step">
            <span class="step-number">3</span>
            <strong>Test the validate-token endpoint</strong>
        </div>
        <div class="form-group">
            <label for="tokenToValidate">Access Token (will auto-fill from test user):</label>
            <input type="text" id="tokenToValidate" placeholder="Token will appear here after creating test user" />
            <button class="copy-btn" onclick="copyToken()">üìã Copy Token</button>
        </div>
        <button onclick="testTokenValidation()">üîê Validate Token</button>
        <button onclick="testInvalidToken()">‚ùå Test Invalid Token</button>
        <div id="validateResponse"></div>
    </div>

    <!-- Get User Token Test -->
    <div class="container">
        <h2>üìß Step 4: Get User Token Test</h2>
        <div class="step">
            <span class="step-number">4</span>
            <strong>Test the get-user-token endpoint</strong>
        </div>
        <div class="form-group">
            <label for="lookupEmail">Email to lookup:</label>
            <input type="email" id="lookupEmail" value="test@example.com" />
        </div>
        <button onclick="testGetUserToken()">üìß Get User Token</button>
        <button onclick="testNonExistentUser()">‚ùå Test Non-existent User</button>
        <div id="getUserResponse"></div>
    </div>

    <!-- Webhook Simulation -->
    <div class="container">
        <h2>üîó Step 5: Webhook Simulation</h2>
        <div class="step">
            <span class="step-number">5</span>
            <strong>Simulate Stripe webhook events</strong>
        </div>
        <div class="form-group">
            <label for="webhookEvent">Event Type:</label>
            <select id="webhookEvent">
                <option value="checkout.session.completed">checkout.session.completed (Create User)</option>
                <option value="invoice.payment_succeeded">invoice.payment_succeeded (Activate)</option>
                <option value="invoice.payment_failed">invoice.payment_failed (Deactivate)</option>
                <option value="customer.subscription.deleted">customer.subscription.deleted (Cancel)</option>
            </select>
        </div>
        <div class="form-group">
            <label for="webhookEmail">Customer Email:</label>
            <input type="email" id="webhookEmail" value="webhook-test@example.com" />
        </div>
        <div class="form-group">
            <label for="customerId">Stripe Customer ID:</label>
            <input type="text" id="customerId" value="cus_webhook_test123" />
        </div>
        <button onclick="simulateWebhook()">üîó Simulate Webhook</button>
        <div id="webhookResponse"></div>
        <div class="info" style="margin-top: 15px; font-size: 12px;">
            ‚ö†Ô∏è Note: This simulates webhook structure but will fail signature verification. 
            Use Stripe Dashboard's "Send test webhook" for real testing with proper signatures.
        </div>
    </div>

    <!-- Complete Flow Test -->
    <div class="container">
        <h2>üöÄ Step 6: Complete Flow Test</h2>
        <div class="step">
            <span class="step-number">6</span>
            <strong>Test the complete user journey</strong>
        </div>
        <button onclick="runCompleteFlowTest()">üöÄ Run Complete Flow Test</button>
        <div id="completeFlowResponse"></div>
    </div>

    <!-- Test Results Summary -->
    <div class="container">
        <h2>üìä Test Results Summary</h2>
        <div class="test-results" id="testSummary">
            <p>Run tests above to see results summary here.</p>
        </div>
    </div>

    <script>
        let testResults = {
            config: null,
            database: null,
            tokenValidation: null,
            getUserToken: null,
            webhook: null,
            completeFlow: null
        };

        let currentTestUser = null;

        // ADD: automatically attach Supabase auth headers to every Edge Function call
        (function () {
            const originalFetch = window.fetch;
            window.fetch = function (url, options = {}) {
                // If calling a Supabase Edge Function and a key is present, inject headers
                try {
                    if (typeof url === 'string' && url.includes('/functions/v1/')) {
                        const keyEl = document.getElementById('supabaseKey');
                        const supaKey = keyEl ? keyEl.value.trim() : '';
                        if (supaKey) {
                            options = options || {};
                            options.headers = {
                                ...(options.headers || {}),
                                apikey: supaKey,
                                Authorization: `Bearer ${supaKey}`
                            };
                        }
                    }
                } catch (err) {
                    console.error('fetch wrapper error', err);
                }
                return originalFetch(url, options);
            };
        })();

        // ADD: generate a valid Stripe signature for test payloads when a secret is provided
        async function generateStripeSignature(secret, payload) {
            if (!secret) return 'test_signature';
            const encoder = new TextEncoder();
            const key = await crypto.subtle.importKey(
                'raw',
                encoder.encode(secret),
                { name: 'HMAC', hash: 'SHA-256' },
                false,
                ['sign']
            );
            const timestamp = Math.floor(Date.now() / 1000).toString();
            const signedPayload = `${timestamp}.${payload}`;
            const signatureBuffer = await crypto.subtle.sign('HMAC', key, encoder.encode(signedPayload));
            const signatureArray = Array.from(new Uint8Array(signatureBuffer));
            const signatureHex = signatureArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return `t=${timestamp},v1=${signatureHex}`;
        }

        function getSupabaseUrl() {
            const url = document.getElementById('supabaseUrl').value;
            if (!url) {
                alert('Please enter your Supabase URL first');
                return null;
            }
            return url.replace(/\/$/, '');
        }

        function showResponse(elementId, response, isError = false, isLoading = false) {
            const element = document.getElementById(elementId);
            if (isLoading) {
                element.className = 'response loading';
                element.textContent = 'Loading...';
                return;
            }
            element.className = `response ${isError ? 'error' : 'success'}`;
            element.textContent = JSON.stringify(response, null, 2);
        }

        function updateTestSummary() {
            const summary = document.getElementById('testSummary');
            let html = '<h3>Test Status:</h3>';
            
            Object.entries(testResults).forEach(([test, result]) => {
                const status = result === null ? 'pending' : (result ? 'success' : 'error');
                const icon = result === null ? '‚è≥' : (result ? '‚úÖ' : '‚ùå');
                html += `<p><span class="status-indicator status-${status}"></span>${icon} ${test.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}</p>`;
            });
            
            summary.innerHTML = html;
        }

        async function validateConfig() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            showResponse('configResponse', null, false, true);

            try {
                // Test if we can reach the functions
                const response = await fetch(`${supabaseUrl}/functions/v1/validate-token`, {
                    method: 'OPTIONS'
                });

                if (response.ok) {
                    testResults.config = true;
                    showResponse('configResponse', { 
                        status: 'Configuration Valid', 
                        url: supabaseUrl,
                        message: 'Successfully connected to Supabase functions'
                    });
                } else {
                    testResults.config = false;
                    showResponse('configResponse', { 
                        error: 'Cannot reach Supabase functions',
                        status: response.status 
                    }, true);
                }
            } catch (error) {
                testResults.config = false;
                showResponse('configResponse', { error: error.message }, true);
            }
            
            updateTestSummary();
        }

        async function createTestUser() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            const email = document.getElementById('testEmail').value;
            const status = document.getElementById('testStatus').value;

            showResponse('databaseResponse', null, false, true);

            // Simulate creating user via webhook
            try {
                const webhookPayload = {
                    type: 'checkout.session.completed',
                    data: {
                        object: {
                            customer: 'cus_test_' + Date.now(),
                            customer_email: email
                        }
                    }
                };

                const payloadStr = JSON.stringify(webhookPayload);
                const sigHeader = await generateStripeSignature(
                    document.getElementById('stripeSecret').value.trim(),
                    payloadStr
                );

                const response = await fetch(`${supabaseUrl}/functions/v1/stripe-webhooks`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'stripe-signature': sigHeader
                    },
                    body: payloadStr
                });

                // Even if webhook fails due to signature, try to get the user token
                // to see if user was created in a previous test
                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait a bit
                
                const tokenResponse = await fetch(`${supabaseUrl}/functions/v1/get-user-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email })
                });

                const tokenData = await tokenResponse.json();
                
                if (tokenData.success && tokenData.token) {
                    currentTestUser = { email, token: tokenData.token, status: tokenData.status };
                    document.getElementById('tokenToValidate').value = tokenData.token;
                    testResults.database = true;
                    showResponse('databaseResponse', {
                        message: 'Test user found/created successfully',
                        user: currentTestUser,
                        note: 'Token auto-filled in validation section'
                    });
                } else {
                    testResults.database = false;
                    showResponse('databaseResponse', {
                        webhook_response: response.status,
                        token_lookup: tokenData,
                        note: 'User creation may have failed. Check Supabase logs.'
                    }, true);
                }
            } catch (error) {
                testResults.database = false;
                showResponse('databaseResponse', { error: error.message }, true);
            }
            
            updateTestSummary();
        }

        async function checkUserExists() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            const email = document.getElementById('testEmail').value;
            showResponse('databaseResponse', null, false, true);

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/get-user-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email })
                });

                const data = await response.json();
                
                if (data.success) {
                    currentTestUser = { email, token: data.token, status: data.status };
                    document.getElementById('tokenToValidate').value = data.token;
                    showResponse('databaseResponse', {
                        message: 'User exists in database',
                        user: currentTestUser
                    });
                } else {
                    showResponse('databaseResponse', {
                        message: 'User not found',
                        response: data
                    }, true);
                }
            } catch (error) {
                showResponse('databaseResponse', { error: error.message }, true);
            }
        }

        async function testTokenValidation() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            const token = document.getElementById('tokenToValidate').value;
            if (!token) {
                alert('Please enter a token or create a test user first');
                return;
            }

            showResponse('validateResponse', null, false, true);

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/validate-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token })
                });

                const data = await response.json();
                testResults.tokenValidation = data.access === true;
                showResponse('validateResponse', { 
                    status: response.status, 
                    data,
                    expected: 'access: true for valid tokens'
                }, !response.ok || !data.access);
            } catch (error) {
                testResults.tokenValidation = false;
                showResponse('validateResponse', { error: error.message }, true);
            }
            
            updateTestSummary();
        }

        async function testInvalidToken() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            showResponse('validateResponse', null, false, true);

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/validate-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: '123e4567-e89b-12d3-a456-426614174000' })
                });

                const data = await response.json();
                const isCorrect = data.access === false;
                showResponse('validateResponse', { 
                    status: response.status, 
                    data,
                    test: 'Invalid token should return access: false',
                    result: isCorrect ? 'PASS' : 'FAIL'
                }, !isCorrect);
            } catch (error) {
                showResponse('validateResponse', { error: error.message }, true);
            }
        }

        async function testGetUserToken() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            const email = document.getElementById('lookupEmail').value;
            showResponse('getUserResponse', null, false, true);

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/get-user-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email })
                });

                const data = await response.json();
                testResults.getUserToken = data.success === true;
                showResponse('getUserResponse', { 
                    status: response.status, 
                    data 
                }, !data.success);
            } catch (error) {
                testResults.getUserToken = false;
                showResponse('getUserResponse', { error: error.message }, true);
            }
            
            updateTestSummary();
        }

        async function testNonExistentUser() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            showResponse('getUserResponse', null, false, true);

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/get-user-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: 'nonexistent@example.com' })
                });

                const data = await response.json();
                const isCorrect = data.success === false;
                showResponse('getUserResponse', { 
                    status: response.status, 
                    data,
                    test: 'Non-existent user should return success: false',
                    result: isCorrect ? 'PASS' : 'FAIL'
                }, !isCorrect);
            } catch (error) {
                showResponse('getUserResponse', { error: error.message }, true);
            }
        }

        async function simulateWebhook() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            const eventType = document.getElementById('webhookEvent').value;
            const email = document.getElementById('webhookEmail').value;
            const customerId = document.getElementById('customerId').value;

            showResponse('webhookResponse', null, false, true);

            let webhookPayload;
            
            switch (eventType) {
                case 'checkout.session.completed':
                    webhookPayload = {
                        type: eventType,
                        data: {
                            object: {
                                customer: customerId,
                                customer_email: email
                            }
                        }
                    };
                    break;
                default:
                    webhookPayload = {
                        type: eventType,
                        data: {
                            object: {
                                customer: customerId
                            }
                        }
                    };
            }

            const payloadStr = JSON.stringify(webhookPayload);
            const sigHeader = await generateStripeSignature(
                document.getElementById('stripeSecret').value.trim(),
                payloadStr
            );

            try {
                const response = await fetch(`${supabaseUrl}/functions/v1/stripe-webhooks`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'stripe-signature': sigHeader
                    },
                    body: payloadStr
                });

                const data = await response.text();
                testResults.webhook = response.status < 500; // Accept signature errors but not server errors
                showResponse('webhookResponse', { 
                    payload: webhookPayload,
                    status: response.status, 
                    response: data,
                    note: 'Signature verification will fail in test mode'
                }, response.status >= 500);
            } catch (error) {
                testResults.webhook = false;
                showResponse('webhookResponse', { error: error.message }, true);
            }
            
            updateTestSummary();
        }

        async function runCompleteFlowTest() {
            const supabaseUrl = getSupabaseUrl();
            if (!supabaseUrl) return;

            showResponse('completeFlowResponse', null, false, true);

            const testEmail = 'complete-test@example.com';
            const results = [];

            try {
                // Step 1: Create user via webhook simulation
                results.push('Step 1: Creating user via webhook...');
                const webhookPayload = {
                    type: 'checkout.session.completed',
                    data: {
                        object: {
                            customer: 'cus_complete_test',
                            customer_email: testEmail
                        }
                    }
                };

                const payloadStr1 = JSON.stringify(webhookPayload);
                const sigHeader1 = await generateStripeSignature(
                    document.getElementById('stripeSecret').value.trim(),
                    payloadStr1
                );

                await fetch(`${supabaseUrl}/functions/v1/stripe-webhooks`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'stripe-signature': sigHeader1
                    },
                    body: payloadStr1
                });

                // Step 2: Get user token
                await new Promise(resolve => setTimeout(resolve, 1000));
                results.push('Step 2: Retrieving user token...');
                
                const tokenResponse = await fetch(`${supabaseUrl}/functions/v1/get-user-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email: testEmail })
                });

                const tokenData = await tokenResponse.json();
                
                if (!tokenData.success) {
                    throw new Error('Failed to get user token: ' + tokenData.message);
                }

                results.push(`‚úÖ Token retrieved: ${tokenData.token.substring(0, 8)}...`);

                // Step 3: Validate token
                results.push('Step 3: Validating token...');
                
                const validateResponse = await fetch(`${supabaseUrl}/functions/v1/validate-token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: tokenData.token })
                });

                const validateData = await validateResponse.json();
                
                if (!validateData.access) {
                    throw new Error('Token validation failed');
                }

                results.push('‚úÖ Token validation successful');

                // Step 4: Test status updates
                results.push('Step 4: Testing status updates...');
                
                const statusUpdatePayload = {
                    type: 'invoice.payment_succeeded',
                    data: {
                        object: {
                            customer: 'cus_complete_test'
                        }
                    }
                };

                const payloadStr2 = JSON.stringify(statusUpdatePayload);
                const sigHeader2 = await generateStripeSignature(
                    document.getElementById('stripeSecret').value.trim(),
                    payloadStr2
                );

                await fetch(`${supabaseUrl}/functions/v1/stripe-webhooks`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'stripe-signature': sigHeader2
                    },
                    body: payloadStr2
                });

                results.push('‚úÖ Complete flow test successful!');
                results.push('');
                results.push('üéâ All systems are working correctly!');
                results.push('Your Promptr backend is ready for production.');

                testResults.completeFlow = true;
                showResponse('completeFlowResponse', {
                    success: true,
                    steps: results,
                    testUser: { email: testEmail, token: tokenData.token }
                });

            } catch (error) {
                results.push(`‚ùå Error: ${error.message}`);
                testResults.completeFlow = false;
                showResponse('completeFlowResponse', {
                    success: false,
                    steps: results,
                    error: error.message
                }, true);
            }
            
            updateTestSummary();
        }

        function copyToken() {
            const token = document.getElementById('tokenToValidate').value;
            if (token) {
                navigator.clipboard.writeText(token);
                alert('Token copied to clipboard!');
            }
        }

        // Initialize
        updateTestSummary();
    </script>
</body>
</html>